// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.10.
// **********************************************************************

#ifndef __GMPARAM_H_
#define __GMPARAM_H_

#include <map>
#include <string>
#include <vector>
#include "Tars.h"
using namespace std;


namespace ptars
{
    struct GMTest : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ptars.GMTest";
        }
        static string MD5()
        {
            return "282dee69d7580ed43b374bb636595df2";
        }
        GMTest()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            uid = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (uid != 0)
            {
                _os.write(uid, 0);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uid, 0, false, "GMTest");
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(uid,"uid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(uid, false);
            return _os;
        }
    public:
        tars::Int64 uid;
    };
    inline bool operator==(const GMTest&l, const GMTest&r)
    {
        return l.uid == r.uid;
    }
    inline bool operator!=(const GMTest&l, const GMTest&r)
    {
        return !(l == r);
    }

    struct GMParam : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ptars.GMParam";
        }
        static string MD5()
        {
            return "a67716b15ecd866369f87484821beea5";
        }
        GMParam()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            serverId = 0;
            puid = 0;
            leagueUid = 0;
            name = 0;
            oasisWarId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (serverId != 0)
            {
                _os.write(serverId, 0);
            }
            if (puid != 0)
            {
                _os.write(puid, 1);
            }
            if (leagueUid != 0)
            {
                _os.write(leagueUid, 2);
            }
            if (name != 0)
            {
                _os.write(name, 3);
            }
            if (oasisWarId != 0)
            {
                _os.write(oasisWarId, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(serverId, 0, false, "GMParam");
            _is.read(puid, 1, false, "GMParam");
            _is.read(leagueUid, 2, false, "GMParam");
            _is.read(name, 3, false, "GMParam");
            _is.read(oasisWarId, 4, false, "GMParam");
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(serverId,"serverId");
            _ds.display(puid,"puid");
            _ds.display(leagueUid,"leagueUid");
            _ds.display(name,"name");
            _ds.display(oasisWarId,"oasisWarId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(serverId, true);
            _ds.displaySimple(puid, true);
            _ds.displaySimple(leagueUid, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(oasisWarId, false);
            return _os;
        }
    public:
        tars::Int64 serverId;
        tars::Int64 puid;
        tars::Int64 leagueUid;
        tars::Int64 name;
        tars::Int64 oasisWarId;
    };
    inline bool operator==(const GMParam&l, const GMParam&r)
    {
        return l.serverId == r.serverId && l.puid == r.puid && l.leagueUid == r.leagueUid && l.name == r.name && l.oasisWarId == r.oasisWarId;
    }
    inline bool operator!=(const GMParam&l, const GMParam&r)
    {
        return !(l == r);
    }

    struct GMActParam : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "ptars.GMActParam";
        }
        static string MD5()
        {
            return "45ba59a9300d258071ab72070312008d";
        }
        GMActParam()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            serverId = 0;
            beginTime = 0;
            endTime = 0;
            effectBeginTime = 0;
            effectEndTime = 0;
            extParam = "";
            extParam2 = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (serverId != 0)
            {
                _os.write(serverId, 0);
            }
            if (beginTime != 0)
            {
                _os.write(beginTime, 1);
            }
            if (endTime != 0)
            {
                _os.write(endTime, 2);
            }
            if (effectBeginTime != 0)
            {
                _os.write(effectBeginTime, 3);
            }
            if (effectEndTime != 0)
            {
                _os.write(effectEndTime, 4);
            }
            if (extParam != "")
            {
                _os.write(extParam, 5);
            }
            if (extParam2 != 0)
            {
                _os.write(extParam2, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(serverId, 0, false, "GMActParam");
            _is.read(beginTime, 1, false, "GMActParam");
            _is.read(endTime, 2, false, "GMActParam");
            _is.read(effectBeginTime, 3, false, "GMActParam");
            _is.read(effectEndTime, 4, false, "GMActParam");
            _is.read(extParam, 5, false, "GMActParam");
            _is.read(extParam2, 6, false, "GMActParam");
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(serverId,"serverId");
            _ds.display(beginTime,"beginTime");
            _ds.display(endTime,"endTime");
            _ds.display(effectBeginTime,"effectBeginTime");
            _ds.display(effectEndTime,"effectEndTime");
            _ds.display(extParam,"extParam");
            _ds.display(extParam2,"extParam2");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(serverId, true);
            _ds.displaySimple(beginTime, true);
            _ds.displaySimple(endTime, true);
            _ds.displaySimple(effectBeginTime, true);
            _ds.displaySimple(effectEndTime, true);
            _ds.displaySimple(extParam, true);
            _ds.displaySimple(extParam2, false);
            return _os;
        }
    public:
        tars::Int64 serverId;
        tars::Int64 beginTime;
        tars::Int64 endTime;
        tars::Int64 effectBeginTime;
        tars::Int64 effectEndTime;
        std::string extParam;
        tars::Int64 extParam2;
    };
    inline bool operator==(const GMActParam&l, const GMActParam&r)
    {
        return l.serverId == r.serverId && l.beginTime == r.beginTime && l.endTime == r.endTime && l.effectBeginTime == r.effectBeginTime && l.effectEndTime == r.effectEndTime && l.extParam == r.extParam && l.extParam2 == r.extParam2;
    }
    inline bool operator!=(const GMActParam&l, const GMActParam&r)
    {
        return !(l == r);
    }


}



#endif
